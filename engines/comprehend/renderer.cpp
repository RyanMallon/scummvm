#include "graphics/palette.h"
#include "graphics/surface.h"

#include "common/rect.h"
#include "common/file.h"
#include "common/debug.h"
#include "common/system.h"

#include "comprehend/comprehend.h"
#include "comprehend/renderer.h"

namespace Comprehend {

// FIXME - move
static const uint8 dosFont[128 * 8] = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x7e, 0x81, 0xa5, 0x81, 0xbd, 0x99, 0x81, 0x7e,
  0x7e, 0xff, 0xdb, 0xff, 0xc3, 0xe7, 0xff, 0x7e,
  0x6c, 0xfe, 0xfe, 0xfe, 0x7c, 0x38, 0x10, 0x00,
  0x10, 0x38, 0x7c, 0xfe, 0x7c, 0x38, 0x10, 0x00,
  0x38, 0x7c, 0x38, 0xfe, 0xfe, 0x7c, 0x38, 0x7c,
  0x10, 0x10, 0x38, 0x7c, 0xfe, 0x7c, 0x38, 0x7c,
  0x00, 0x00, 0x18, 0x3c, 0x3c, 0x18, 0x00, 0x00,
  0xff, 0xff, 0xe7, 0xc3, 0xc3, 0xe7, 0xff, 0xff,
  0x00, 0x3c, 0x66, 0x42, 0x42, 0x66, 0x3c, 0x00,
  0xff, 0xc3, 0x99, 0xbd, 0xbd, 0x99, 0xc3, 0xff,
  0x0f, 0x07, 0x0f, 0x7d, 0xcc, 0xcc, 0xcc, 0x78,
  0x3c, 0x66, 0x66, 0x66, 0x3c, 0x18, 0x7e, 0x18,
  0x3f, 0x33, 0x3f, 0x30, 0x30, 0x70, 0xf0, 0xe0,
  0x7f, 0x63, 0x7f, 0x63, 0x63, 0x67, 0xe6, 0xc0,
  0x99, 0x5a, 0x3c, 0xe7, 0xe7, 0x3c, 0x5a, 0x99,
  0x80, 0xe0, 0xf8, 0xfe, 0xf8, 0xe0, 0x80, 0x00,
  0x02, 0x0e, 0x3e, 0xfe, 0x3e, 0x0e, 0x02, 0x00,
  0x18, 0x3c, 0x7e, 0x18, 0x18, 0x7e, 0x3c, 0x18,
  0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x66, 0x00,
  0x7f, 0xdb, 0xdb, 0x7b, 0x1b, 0x1b, 0x1b, 0x00,
  0x3e, 0x63, 0x38, 0x6c, 0x6c, 0x38, 0xcc, 0x78,
  0x00, 0x00, 0x00, 0x00, 0x7e, 0x7e, 0x7e, 0x00,
  0x18, 0x3c, 0x7e, 0x18, 0x7e, 0x3c, 0x18, 0xff,
  0x18, 0x3c, 0x7e, 0x18, 0x18, 0x18, 0x18, 0x00,
  0x18, 0x18, 0x18, 0x18, 0x7e, 0x3c, 0x18, 0x00,
  0x00, 0x18, 0x0c, 0xfe, 0x0c, 0x18, 0x00, 0x00,
  0x00, 0x30, 0x60, 0xfe, 0x60, 0x30, 0x00, 0x00,
  0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xfe, 0x00, 0x00,
  0x00, 0x24, 0x66, 0xff, 0x66, 0x24, 0x00, 0x00,
  0x00, 0x18, 0x3c, 0x7e, 0xff, 0xff, 0x00, 0x00,
  0x00, 0xff, 0xff, 0x7e, 0x3c, 0x18, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x30, 0x78, 0x78, 0x30, 0x30, 0x00, 0x30, 0x00,
  0x6c, 0x6c, 0x6c, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x6c, 0x6c, 0xfe, 0x6c, 0xfe, 0x6c, 0x6c, 0x00,
  0x30, 0x7c, 0xc0, 0x78, 0x0c, 0xf8, 0x30, 0x00,
  0x00, 0xc6, 0xcc, 0x18, 0x30, 0x66, 0xc6, 0x00,
  0x38, 0x6c, 0x38, 0x76, 0xdc, 0xcc, 0x76, 0x00,
  0x60, 0x60, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x18, 0x30, 0x60, 0x60, 0x60, 0x30, 0x18, 0x00,
  0x60, 0x30, 0x18, 0x18, 0x18, 0x30, 0x60, 0x00,
  0x00, 0x66, 0x3c, 0xff, 0x3c, 0x66, 0x00, 0x00,
  0x00, 0x30, 0x30, 0xfc, 0x30, 0x30, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x60,
  0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00,
  0x06, 0x0c, 0x18, 0x30, 0x60, 0xc0, 0x80, 0x00,
  0x7c, 0xc6, 0xce, 0xde, 0xf6, 0xe6, 0x7c, 0x00,
  0x30, 0x70, 0x30, 0x30, 0x30, 0x30, 0xfc, 0x00,
  0x78, 0xcc, 0x0c, 0x38, 0x60, 0xcc, 0xfc, 0x00,
  0x78, 0xcc, 0x0c, 0x38, 0x0c, 0xcc, 0x78, 0x00,
  0x1c, 0x3c, 0x6c, 0xcc, 0xfe, 0x0c, 0x1e, 0x00,
  0xfc, 0xc0, 0xf8, 0x0c, 0x0c, 0xcc, 0x78, 0x00,
  0x38, 0x60, 0xc0, 0xf8, 0xcc, 0xcc, 0x78, 0x00,
  0xfc, 0xcc, 0x0c, 0x18, 0x30, 0x30, 0x30, 0x00,
  0x78, 0xcc, 0xcc, 0x78, 0xcc, 0xcc, 0x78, 0x00,
  0x78, 0xcc, 0xcc, 0x7c, 0x0c, 0x18, 0x70, 0x00,
  0x00, 0x30, 0x30, 0x00, 0x00, 0x30, 0x30, 0x00,
  0x00, 0x30, 0x30, 0x00, 0x00, 0x30, 0x30, 0x60,
  0x18, 0x30, 0x60, 0xc0, 0x60, 0x30, 0x18, 0x00,
  0x00, 0x00, 0xfc, 0x00, 0x00, 0xfc, 0x00, 0x00,
  0x60, 0x30, 0x18, 0x0c, 0x18, 0x30, 0x60, 0x00,
  0x78, 0xcc, 0x0c, 0x18, 0x30, 0x00, 0x30, 0x00,
  0x7c, 0xc6, 0xde, 0xde, 0xde, 0xc0, 0x78, 0x00,
  0x30, 0x78, 0xcc, 0xcc, 0xfc, 0xcc, 0xcc, 0x00,
  0xfc, 0x66, 0x66, 0x7c, 0x66, 0x66, 0xfc, 0x00,
  0x3c, 0x66, 0xc0, 0xc0, 0xc0, 0x66, 0x3c, 0x00,
  0xf8, 0x6c, 0x66, 0x66, 0x66, 0x6c, 0xf8, 0x00,
  0xfe, 0x62, 0x68, 0x78, 0x68, 0x62, 0xfe, 0x00,
  0xfe, 0x62, 0x68, 0x78, 0x68, 0x60, 0xf0, 0x00,
  0x3c, 0x66, 0xc0, 0xc0, 0xce, 0x66, 0x3e, 0x00,
  0xcc, 0xcc, 0xcc, 0xfc, 0xcc, 0xcc, 0xcc, 0x00,
  0x78, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00,
  0x1e, 0x0c, 0x0c, 0x0c, 0xcc, 0xcc, 0x78, 0x00,
  0xe6, 0x66, 0x6c, 0x78, 0x6c, 0x66, 0xe6, 0x00,
  0xf0, 0x60, 0x60, 0x60, 0x62, 0x66, 0xfe, 0x00,
  0xc6, 0xee, 0xfe, 0xfe, 0xd6, 0xc6, 0xc6, 0x00,
  0xc6, 0xe6, 0xf6, 0xde, 0xce, 0xc6, 0xc6, 0x00,
  0x38, 0x6c, 0xc6, 0xc6, 0xc6, 0x6c, 0x38, 0x00,
  0xfc, 0x66, 0x66, 0x7c, 0x60, 0x60, 0xf0, 0x00,
  0x78, 0xcc, 0xcc, 0xcc, 0xdc, 0x78, 0x1c, 0x00,
  0xfc, 0x66, 0x66, 0x7c, 0x6c, 0x66, 0xe6, 0x00,
  0x78, 0xcc, 0xe0, 0x70, 0x1c, 0xcc, 0x78, 0x00,
  0xfc, 0xb4, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00,
  0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xfc, 0x00,
  0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x00,
  0xc6, 0xc6, 0xc6, 0xd6, 0xfe, 0xee, 0xc6, 0x00,
  0xc6, 0xc6, 0x6c, 0x38, 0x38, 0x6c, 0xc6, 0x00,
  0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x30, 0x78, 0x00,
  0xfe, 0xc6, 0x8c, 0x18, 0x32, 0x66, 0xfe, 0x00,
  0x78, 0x60, 0x60, 0x60, 0x60, 0x60, 0x78, 0x00,
  0xc0, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x02, 0x00,
  0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0x78, 0x00,
  0x10, 0x38, 0x6c, 0xc6, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
  0x30, 0x30, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0x76, 0x00,
  0xe0, 0x60, 0x60, 0x7c, 0x66, 0x66, 0xdc, 0x00,
  0x00, 0x00, 0x78, 0xcc, 0xc0, 0xcc, 0x78, 0x00,
  0x1c, 0x0c, 0x0c, 0x7c, 0xcc, 0xcc, 0x76, 0x00,
  0x00, 0x00, 0x78, 0xcc, 0xfc, 0xc0, 0x78, 0x00,
  0x38, 0x6c, 0x60, 0xf0, 0x60, 0x60, 0xf0, 0x00,
  0x00, 0x00, 0x76, 0xcc, 0xcc, 0x7c, 0x0c, 0xf8,
  0xe0, 0x60, 0x6c, 0x76, 0x66, 0x66, 0xe6, 0x00,
  0x30, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00,
  0x0c, 0x00, 0x0c, 0x0c, 0x0c, 0xcc, 0xcc, 0x78,
  0xe0, 0x60, 0x66, 0x6c, 0x78, 0x6c, 0xe6, 0x00,
  0x70, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00,
  0x00, 0x00, 0xcc, 0xfe, 0xfe, 0xd6, 0xc6, 0x00,
  0x00, 0x00, 0xf8, 0xcc, 0xcc, 0xcc, 0xcc, 0x00,
  0x00, 0x00, 0x78, 0xcc, 0xcc, 0xcc, 0x78, 0x00,
  0x00, 0x00, 0xdc, 0x66, 0x66, 0x7c, 0x60, 0xf0,
  0x00, 0x00, 0x76, 0xcc, 0xcc, 0x7c, 0x0c, 0x1e,
  0x00, 0x00, 0xdc, 0x76, 0x66, 0x60, 0xf0, 0x00,
  0x00, 0x00, 0x7c, 0xc0, 0x78, 0x0c, 0xf8, 0x00,
  0x10, 0x30, 0x7c, 0x30, 0x30, 0x34, 0x18, 0x00,
  0x00, 0x00, 0xcc, 0xcc, 0xcc, 0xcc, 0x76, 0x00,
  0x00, 0x00, 0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x00,
  0x00, 0x00, 0xc6, 0xd6, 0xfe, 0xfe, 0x6c, 0x00,
  0x00, 0x00, 0xc6, 0x6c, 0x38, 0x6c, 0xc6, 0x00,
  0x00, 0x00, 0xcc, 0xcc, 0xcc, 0x7c, 0x0c, 0xf8,
  0x00, 0x00, 0xfc, 0x98, 0x30, 0x64, 0xfc, 0x00,
  0x1c, 0x30, 0x30, 0xe0, 0x30, 0x30, 0x1c, 0x00,
  0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00,
  0xe0, 0x30, 0x30, 0x1c, 0x30, 0x30, 0xe0, 0x00,
  0x76, 0xdc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x10, 0x38, 0x6c, 0xc6, 0xc6, 0xfe, 0x00,
};

#define IMAGE_OP_END			0x00

#define IMAGE_OP_SET_TEXT_POS		0x10

#define IMAGE_OP_PEN_COLOR_A		0x20
#define IMAGE_OP_PEN_COLOR_B		0x21
#define IMAGE_OP_PEN_COLOR_C		0x22
#define IMAGE_OP_PEN_COLOR_D		0x23
#define IMAGE_OP_PEN_COLOR_E		0x24
#define IMAGE_OP_PEN_COLOR_F		0x25
#define IMAGE_OP_PEN_COLOR_G		0x26
#define IMAGE_OP_PEN_COLOR_H		0x27

#define IMAGE_OP_DRAW_CHAR		0x30

#define IMAGE_OP_SHAPE_PIXEL		0x40
#define IMAGE_OP_SHAPE_BOX		0x41
#define IMAGE_OP_SHAPE_CIRCLE_TINY	0x42
#define IMAGE_OP_SHAPE_CIRCLE_SMALL	0x43
#define IMAGE_OP_SHAPE_CIRCLE_MED	0x44
#define IMAGE_OP_SHAPE_CIRCLE_LARGE	0x45
#define IMAGE_OP_SHAPE_A		0x46
#define IMAGE_OP_SHAPE_SPRAY		0x47

#define IMAGE_OP_EOF			0x55

#define IMAGE_OP_FILL_COLOR		0x60

#define IMAGE_OP_MOVE_TO		0x80
#define IMAGE_OP_MOVE_TO_FAR		0x81

#define IMAGE_OP_DRAW_BOX		0x90
#define IMAGE_OP_DRAW_BOX_FAR		0x91

#define IMAGE_OP_DRAW_LINE		0xa0
#define IMAGE_OP_DRAW_LINE_FAR		0xa1

#define IMAGE_OP_DRAW_SHAPE		0xc0
#define IMAGE_OP_DRAW_SHAPE_FAR		0xc1

#define IMAGE_OP_PAINT			0xe0
#define IMAGE_OP_PAINT_FAR		0xe1

static const int kGraphicsWidth		= 278;
// FIXME - shared constant with console
static const int kGraphicsHeight	= (200 - 40);

static const int penColors[] = {
	Renderer::kColorWhite,
	0x3e, // dark green
	0x5a, // green
	Renderer::kColorWhite,
	Renderer::kColorBlack,
	0x60, // purple
	0x6a, // blue
	0x5a, // green
};

Renderer::Renderer(ImageManager *imageManager) : _imageManager(imageManager) {
	byte _palette[256 * 3] = {
		0xff, 0xff, 0xff, // 00
		0x00, 0xff, 0x00, // 01
		0x00, 0xff, 0x00, // 02
		0xb0, 0x00, 0x00, // 03 (wagon)
		0x00, 0x99, 0xff, // 04 (blue - highlight walls)
		0x00, 0xff, 0x00, // 05
		0x00, 0xff, 0x00, // 06
		0x00, 0xff, 0x00, // 07
		0x00, 0xff, 0x00, // 08
		0x00, 0xff, 0x00, // 09
		0x00, 0xff, 0x00, // 0a
		0x00, 0xff, 0x00, // 0b
		0x00, 0xff, 0x00, // 0c
		0xff, 0xff, 0x00, // 0d (deer head)
		0x00, 0xff, 0x00, // 0e
		0x00, 0xff, 0x00, // 0f

		0x00, 0xff, 0x00, // 10
		0x00, 0xff, 0x00, // 11
		0x00, 0xff, 0x00, // 12
		0x00, 0xff, 0x00, // 13
		0x00, 0xff, 0x00, // 14
		0x00, 0xff, 0x00, // 15
		0x00, 0xff, 0x00, // 16
		0x00, 0xff, 0x00, // 17
		0x00, 0xff, 0x00, // 18
		0x00, 0xff, 0x00, // 19
		0x00, 0xff, 0x00, // 1a
		0x00, 0xff, 0x00, // 1b
		0x00, 0xff, 0x00, // 1c
		0x00, 0xff, 0x00, // 1d
		0x00, 0xff, 0x00, // 1e
		0x00, 0xff, 0x00, // 1f

		0x00, 0xff, 0x00, // 20
		0x00, 0xff, 0x00, // 21
		0x00, 0xff, 0x00, // 22
		0x00, 0xff, 0x00, // 23
		0x00, 0xff, 0x00, // 24
		0x00, 0xff, 0x00, // 25
		0x00, 0xff, 0x00, // 26
		0x00, 0xff, 0x00, // 27
		0x00, 0xff, 0x00, // 28
		0x00, 0xff, 0x00, // 29
		0x00, 0xff, 0x00, // 2a
		0x00, 0xff, 0x00, // 2b
		0x00, 0xff, 0x00, // 2c
		0x00, 0xff, 0x00, // 2d
		0x00, 0xff, 0x00, // 2e
		0x00, 0xff, 0x00, // 2f

		0x00, 0xff, 0x00, // 30
		0x00, 0xff, 0x00, // 31
		0x00, 0xff, 0x00, // 32
		0x00, 0xff, 0x00, // 33
		0xff, 0xff, 0xff, // 34 (white - bread middle)
		0x00, 0x00, 0x50, // 35 (dark blue - house interoir wall/forest bacground)
		0xb5, 0x6c, 0x48, // 36 (brown - bread)
		0x00, 0xff, 0x00, // 37
		0x00, 0xff, 0x00, // 38
		0x00, 0xff, 0x00, // 39
		0x00, 0xff, 0x00, // 3a
		0x00, 0xff, 0x00, // 3b
		0x00, 0xff, 0x00, // 3c
		0x00, 0xff, 0x00, // 3d
		0x00, 0x70, 0x00, // 3e (dark green)
		0x00, 0x80, 0x00, // 3f (dark green)

		0x00, 0xff, 0x00, // 40
		0x00, 0xff, 0x00, // 41
		0x00, 0xff, 0x00, // 42
		0x00, 0xff, 0x00, // 43
		0x00, 0xff, 0x00, // 44
		0x7a, 0x52, 0x00, // 45 (brown)
		0x66, 0x33, 0x00, // 46 (brown - house stairs)
		0x00, 0xff, 0x00, // 47
		0x40, 0x00, 0x00, // 48 (dark red - house interior wall)
		0x00, 0xff, 0x00, // 49
		0x00, 0xff, 0x00, // 4a
		0x00, 0xff, 0x00, // 4b
		0x00, 0xff, 0x00, // 4c
		0x00, 0xff, 0x00, // 4d
		0x00, 0xff, 0x00, // 4e
		0x00, 0xff, 0x00, // 4f

		0x00, 0x00, 0x00, // 50 (black)
		0x00, 0xff, 0x00, // 51
		0x00, 0xff, 0x00, // 52
		0x00, 0xff, 0x00, // 53
		0x66, 0x33, 0x00, // 54 (brown)
		0x00, 0xff, 0x00, // 55
		0x00, 0xff, 0x00, // 56
		0x00, 0xa0, 0x00, // 57 (green)
		0x00, 0xff, 0x00, // 58
		0x00, 0xff, 0x00, // 59
		0x00, 0xb0, 0x00, // 5a (green - grass)
		0x00, 0xff, 0x00, // 5b
		0xcc, 0x00, 0x00, // 5c (red - house roof trim)
		0x80, 0x80, 0x80, // 5d (grey - path)
		0x00, 0xff, 0x00, // 5e
		0x00, 0xff, 0x00, // 5f

		0x80, 0x00, 0x80, // 60 (purple - shed front)
		0x00, 0xff, 0x00, // 61
		0x00, 0xff, 0x00, // 62
		0x00, 0xff, 0x00, // 63
		0x00, 0xff, 0x00, // 64
		0xb0, 0x00, 0x00, // 65 (red - house rafters)
		0x00, 0xff, 0x00, // 66
		0x00, 0xff, 0x00, // 67
		0x00, 0xff, 0x00, // 68
		0x00, 0xff, 0x00, // 69
		0x00, 0x00, 0xa0, // 6a (blue - house)
		0x40, 0x40, 0x40, // 6b (dark grey - house base)
		0x00, 0xff, 0x00, // 6c
		0x00, 0xff, 0x00, // 6d
		0x00, 0xff, 0x00, // 6e
		0x00, 0xff, 0x00, // 6f

		0x00, 0xff, 0x00, // 70
		0x00, 0xff, 0x00, // 71
		0x00, 0xff, 0x00, // 72
		0x00, 0xff, 0x00, // 73
		0x00, 0xff, 0x00, // 74
		0x00, 0xff, 0x00, // 75
		0x00, 0xff, 0x00, // 76
		0x00, 0xff, 0x00, // 77
		0x00, 0xff, 0x00, // 78
		0x00, 0xff, 0x00, // 79
		0x00, 0xff, 0x00, // 7a
		0x00, 0xff, 0x00, // 7b
		0x00, 0xff, 0x00, // 7c
		0x00, 0xff, 0x00, // 7d
		0x00, 0xff, 0x00, // 7e
		0x00, 0xff, 0x00, // 7f

		0x00, 0x00, 0x00, // 80
	};

	g_system->getPaletteManager()->setPalette(_palette, 0, 0x80);

	_surf.create(kGraphicsWidth, kGraphicsHeight, Graphics::PixelFormat::createFormatCLUT8());

	// Clear the screen to black
	g_system->fillScreen(~0);
}

Renderer::~Renderer() {
	_surf.free();
}

int Renderer::getPixel(int x, int y) {
	byte *pixelData = (byte *)_surf.getPixels();

	return pixelData[(kGraphicsWidth * y) + x];
}

void Renderer::putPixel(int x, int y, int color) {
	byte *pixelData = (byte *)_surf.getPixels();

	pixelData[(kGraphicsWidth * y) + x] = color;
}

void Renderer::updateBox(unsigned x1, unsigned y1, unsigned x2, unsigned y2) {
	int xPad = (g_system->getWidth() - kGraphicsWidth) / 2;
	unsigned width, height;

	// Clamp to within screen bounds
	x1 = MIN(x1, (unsigned)kGraphicsWidth);
	y1 = MIN(y1, (unsigned)kGraphicsHeight);
	x2 = MIN(x2, (unsigned)kGraphicsWidth);
	y2 = MIN(y2, (unsigned)kGraphicsHeight);

	if (x1 > x2)
		SWAP(x1, x2);

	if (y1 > y2)
		SWAP(y1, y2);

	// Ensure the update box is at least one pixel
	width = MAX(x2 - x1, 1U);
	height = MAX(y2 - y1, 1U);

	g_system->copyRectToScreen(_surf.getBasePtr(x1, y1), kGraphicsWidth, xPad + x1, y1, width, height);
	g_system->updateScreen();
}

void Renderer::updateScreen() {
	int xPad = (g_system->getWidth() - kGraphicsWidth) / 2;

	g_system->copyRectToScreen(_surf.getBasePtr(0, 0), kGraphicsWidth, xPad, 0, kGraphicsWidth, kGraphicsHeight);
	g_system->updateScreen();
}

void Renderer::floodFill(int x, int y, int oldColor) {
	int x1, x2, i;

	if (getPixel(x, y) != oldColor || _fillColor == oldColor)
		return;

	if (x < 0 || x >= kGraphicsWidth || y < 0 || y >= kGraphicsHeight)
		return;

	// Find the left and right ends of the current scanline
	for (x1 = x; x1 > 0; x1--)
		if (getPixel(x1 - 1, y) != oldColor)
			break;
	for (x2 = x; x2 < kGraphicsWidth - 1; x2++)
		if (getPixel(x2 + 1, y) != oldColor)
			break;

	// Draw the current scanline
	_surf.drawLine(x1, y, x2, y, _fillColor);
	updateBox(x1, y, x2, y);

	// Recursively draw the above scanlines
	for (i = x1; i < x2; i++)
		if (y > 0 && getPixel(i, y - 1) == oldColor)
			floodFill(i, y - 1, oldColor);

	// Recursively draw the below scanlines
	for (i = x1; i < x2; i++)
		if (y < kGraphicsHeight - 1 && getPixel(i, y + 1) == oldColor)
			floodFill(i, y + 1, oldColor);
}

void Renderer::drawShape(int x, int y, int shape, int color) {
	int i, j;

	switch (shape) {
	case IMAGE_OP_SHAPE_PIXEL:
		x += 7;
		y += 7;
		putPixel(x, y, color);
		updateBox(x, y, x + 1, y + 1);
		break;

	case IMAGE_OP_SHAPE_BOX:
		x += 6;
		y += 7;
		_surf.fillRect(Common::Rect(x, y, x + 2, y + 2), color);
		updateBox(x, y, x + 2, y + 2);
		break;

	case IMAGE_OP_SHAPE_CIRCLE_TINY:
		x += 5;
		y += 5;
		_surf.fillRect(Common::Rect(x + 1, y, x + 3, y + 4), color);
		_surf.fillRect(Common::Rect(x, y + 1, x + 4, y + 3), color);
		updateBox(x, y, x + 4, y + 4);
		break;

	case IMAGE_OP_SHAPE_CIRCLE_SMALL:
		x += 4;
		y += 4;
		_surf.fillRect(Common::Rect(x + 1, y, x + 5, y + 6), color);
		_surf.fillRect(Common::Rect(x, y + 1, x + 6, y + 5), color);
		updateBox(x, y, x + 6, y + 6);
		break;

	case IMAGE_OP_SHAPE_CIRCLE_MED:
		x += 1;
		y += 1;
		_surf.fillRect(Common::Rect(x + 1, y + 1, x + 9, y + 9), color);
		_surf.fillRect(Common::Rect(x + 3, y, x + 7, y + 10), color);
		_surf.fillRect(Common::Rect(x, y + 3, x + 10, y + 7), color);
		updateBox(x, y, x + 10, y + 10);
		break;

	case IMAGE_OP_SHAPE_CIRCLE_LARGE:
		_surf.fillRect(Common::Rect(x + 2, y + 1, x + 12, y + 13), color);
		_surf.fillRect(Common::Rect(x + 1, y + 2, x + 13, y + 12), color);
		_surf.fillRect(Common::Rect(x + 5, y, x + 9, y + 14), color);
		_surf.fillRect(Common::Rect(x, y + 5, x + 14, y + 9), color);
		updateBox(x, y, x + 14, y + 14);
		break;

	case IMAGE_OP_SHAPE_SPRAY:
		{
			char spray[13][13] = {
				{0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0},
				{0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0},
				{0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1},
				{0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0},
				{1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0},
				{0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0},
				{0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0},
				{1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0},
				{0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0},
				{1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0},
				{0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0},
				{0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0},
				{0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0},
			};

			for (i = 0; i < 13; i++)
				for (j = 0; j < 13; j++)
					if (spray[i][j])
						putPixel(x + i, y + j, color);
			updateBox(x, y, x + 13, y + 13);
		}
		break;

	default:
		//debug("Unknown shape: %d", shape);
		break;
	}
}

void Renderer::doImageOpcode(Common::File *file, uint8 opcode) {
	unsigned int a, b;

	switch (opcode) {
	case IMAGE_OP_MOVE_TO:
	case IMAGE_OP_MOVE_TO_FAR:
		a = file->readByte();
		b = file->readByte();

		if (opcode & 0x1)
			a += 0xff;

		debugC(1, Comprehend::kDebugGraphics, "move_to(%d, %d)", a, b);
		_penX = a;
		_penY = b;
		break;

	case IMAGE_OP_DRAW_LINE:
	case IMAGE_OP_DRAW_LINE_FAR:
		a = file->readByte();
		b = file->readByte();

		if (opcode & 1)
			a += 0xff;

		debugC(1, Comprehend::kDebugGraphics, "line(%d, %d)-(%d, %d), color=%.2x", _penX, _penY, a, b, _penColor);
		_surf.drawLine(_penX, _penY, a, b, _penColor);
		updateBox(_penX, _penY, a, b);
		_penX = a;
		_penY = b;

		break;

	case IMAGE_OP_DRAW_BOX:
	case IMAGE_OP_DRAW_BOX_FAR:
		// FIXME
		a = file->readByte();
		b = file->readByte();
		break;

	case IMAGE_OP_SHAPE_PIXEL:
	case IMAGE_OP_SHAPE_BOX:
	case IMAGE_OP_SHAPE_CIRCLE_TINY:
	case IMAGE_OP_SHAPE_CIRCLE_SMALL:
	case IMAGE_OP_SHAPE_CIRCLE_MED:
	case IMAGE_OP_SHAPE_CIRCLE_LARGE:
	case IMAGE_OP_SHAPE_A:
	case IMAGE_OP_SHAPE_SPRAY:
		_currentShape = opcode;
		break;

	case IMAGE_OP_DRAW_SHAPE:
	case IMAGE_OP_DRAW_SHAPE_FAR:
		a = file->readByte();
		b = file->readByte();
		drawShape(a, b, _currentShape, _fillColor);
		break;

	case IMAGE_OP_SET_TEXT_POS:
		_textX = file->readByte();
		_textY = file->readByte();
		break;

	case IMAGE_OP_DRAW_CHAR:
		a = file->readByte();
		drawChar(a, _textX, _textY, _fillColor);
		updateBox(_textX, _textY, 8, 8);
		_textX += 8;
		break;

	case IMAGE_OP_PAINT:
	case IMAGE_OP_PAINT_FAR:
		a = file->readByte();
		b = file->readByte();

		if (opcode & 0x1)
			a += 0xff;

		debugC(1, Comprehend::kDebugGraphics, "paint(%d, %d) color=%.2x", a, b, _fillColor);
		floodFill(a, b, getPixel(a, b));
		break;

	case IMAGE_OP_PEN_COLOR_A:
	case IMAGE_OP_PEN_COLOR_B:
	case IMAGE_OP_PEN_COLOR_C:
	case IMAGE_OP_PEN_COLOR_D:
	case IMAGE_OP_PEN_COLOR_E:
	case IMAGE_OP_PEN_COLOR_F:
	case IMAGE_OP_PEN_COLOR_G:
	case IMAGE_OP_PEN_COLOR_H:
		// FIXME
		break;

	case IMAGE_OP_FILL_COLOR:
		_fillColor = file->readByte();
		debugC(1, Comprehend::kDebugGraphics, "set_fill_color(%.2x)", _fillColor);
		break;

	default:
		debugC(1, Comprehend::kDebugGraphics, "  unknown opcode %.2x", opcode);
		break;
	}
}

void Renderer::drawImage(Common::File *file, off_t offset) {
	uint8 opcode;

	_penX = 0;
	_penY = 0;
	_penColor = kColorBlack;
	_fillColor = kColorWhite;

	file->seek(offset, SEEK_SET);
	while (1) {
		opcode = file->readByte();
		if (opcode == IMAGE_OP_END)
			break;

		doImageOpcode(file, opcode);
		g_system->delayMillis(1);
	}

	updateScreen();
}

void Renderer::drawObjectImage(uint16 index) {
	unsigned int fileIndex, imageIndex;
	ImageFile *imageFile;

	fileIndex  = index / ImageFile::kImagesPerFile;
	imageIndex = index % ImageFile::kImagesPerFile;

	if (fileIndex >= _imageManager->_roomImageFiles.size())
		error("Invalid object image index %d\n", index);

	imageFile = _imageManager->_objectImageFiles[fileIndex];
	drawImage(&imageFile->_file, imageFile->_imageOffsets[imageIndex]);
}

void Renderer::drawRoomImage(uint16 index) {
	unsigned int fileIndex, imageIndex;
	ImageFile *imageFile;

	fileIndex  = index / ImageFile::kImagesPerFile;
	imageIndex = index % ImageFile::kImagesPerFile;

	if (fileIndex >= _imageManager->_roomImageFiles.size())
		error("Invalid room image index %d\n", index);

	imageFile = _imageManager->_roomImageFiles[fileIndex];

	// Clear to white
	_surf.fillRect(Common::Rect(0, 0, kGraphicsWidth, kGraphicsHeight), kColorWhite);
	updateScreen();

	drawImage(&imageFile->_file, imageFile->_imageOffsets[imageIndex]);

	// Blank the area for the text parser
	_surf.fillRect(Common::Rect(0, 160, kGraphicsWidth, kGraphicsHeight), kColorBlack);
	updateScreen();
}

void Renderer::drawDarkRoom() {
	// Clear to black
	_surf.fillRect(Common::Rect(0, 0, kGraphicsWidth, kGraphicsHeight), kColorBlack);
	updateScreen();
}

void Renderer::drawChar(uint8 c, int x, int y, int color) {
	const uint8 *charData;
	int i, j;

	if (c >= 128)
		return;

	charData = &dosFont[c * 8];
	for (i = 0; i < 8; i++) {
		for (j = 7; j >= 0; j--) {
			if (*charData & (1 << j))
				_surf.fillRect(Common::Rect(x, y, x + 1, y + 1), color);
			x++;
		}

		charData++;
		y++;
		x -= 8;
	}
}

void Renderer::drawString(const char *string, int x, int y, int color) {
	unsigned int i;

	for (i = 0; i < strlen(string); i++)
		drawChar(string[i], x + (i * 8), y, color);

	//updateScreen();
}

void Renderer::copyRect(const void *pixels, int pitch, Common::Rect rect) {
	g_system->copyRectToScreen(pixels, pitch, rect.left, rect.top, rect.width(), rect.height());
	g_system->updateScreen();
}

} // End of namespace Comprehend
