#include "graphics/palette.h"
#include "graphics/surface.h"

#include "common/rect.h"
#include "common/file.h"
#include "common/debug.h"
#include "common/system.h"

#include "comprehend/comprehend.h"
#include "comprehend/renderer.h"

namespace Comprehend {

// FIXME - move
static const uint8 dosFont[128 * 8] = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x7e, 0x81, 0xa5, 0x81, 0xbd, 0x99, 0x81, 0x7e,
  0x7e, 0xff, 0xdb, 0xff, 0xc3, 0xe7, 0xff, 0x7e,
  0x6c, 0xfe, 0xfe, 0xfe, 0x7c, 0x38, 0x10, 0x00,
  0x10, 0x38, 0x7c, 0xfe, 0x7c, 0x38, 0x10, 0x00,
  0x38, 0x7c, 0x38, 0xfe, 0xfe, 0x7c, 0x38, 0x7c,
  0x10, 0x10, 0x38, 0x7c, 0xfe, 0x7c, 0x38, 0x7c,
  0x00, 0x00, 0x18, 0x3c, 0x3c, 0x18, 0x00, 0x00,
  0xff, 0xff, 0xe7, 0xc3, 0xc3, 0xe7, 0xff, 0xff,
  0x00, 0x3c, 0x66, 0x42, 0x42, 0x66, 0x3c, 0x00,
  0xff, 0xc3, 0x99, 0xbd, 0xbd, 0x99, 0xc3, 0xff,
  0x0f, 0x07, 0x0f, 0x7d, 0xcc, 0xcc, 0xcc, 0x78,
  0x3c, 0x66, 0x66, 0x66, 0x3c, 0x18, 0x7e, 0x18,
  0x3f, 0x33, 0x3f, 0x30, 0x30, 0x70, 0xf0, 0xe0,
  0x7f, 0x63, 0x7f, 0x63, 0x63, 0x67, 0xe6, 0xc0,
  0x99, 0x5a, 0x3c, 0xe7, 0xe7, 0x3c, 0x5a, 0x99,
  0x80, 0xe0, 0xf8, 0xfe, 0xf8, 0xe0, 0x80, 0x00,
  0x02, 0x0e, 0x3e, 0xfe, 0x3e, 0x0e, 0x02, 0x00,
  0x18, 0x3c, 0x7e, 0x18, 0x18, 0x7e, 0x3c, 0x18,
  0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x66, 0x00,
  0x7f, 0xdb, 0xdb, 0x7b, 0x1b, 0x1b, 0x1b, 0x00,
  0x3e, 0x63, 0x38, 0x6c, 0x6c, 0x38, 0xcc, 0x78,
  0x00, 0x00, 0x00, 0x00, 0x7e, 0x7e, 0x7e, 0x00,
  0x18, 0x3c, 0x7e, 0x18, 0x7e, 0x3c, 0x18, 0xff,
  0x18, 0x3c, 0x7e, 0x18, 0x18, 0x18, 0x18, 0x00,
  0x18, 0x18, 0x18, 0x18, 0x7e, 0x3c, 0x18, 0x00,
  0x00, 0x18, 0x0c, 0xfe, 0x0c, 0x18, 0x00, 0x00,
  0x00, 0x30, 0x60, 0xfe, 0x60, 0x30, 0x00, 0x00,
  0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xfe, 0x00, 0x00,
  0x00, 0x24, 0x66, 0xff, 0x66, 0x24, 0x00, 0x00,
  0x00, 0x18, 0x3c, 0x7e, 0xff, 0xff, 0x00, 0x00,
  0x00, 0xff, 0xff, 0x7e, 0x3c, 0x18, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x30, 0x78, 0x78, 0x30, 0x30, 0x00, 0x30, 0x00,
  0x6c, 0x6c, 0x6c, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x6c, 0x6c, 0xfe, 0x6c, 0xfe, 0x6c, 0x6c, 0x00,
  0x30, 0x7c, 0xc0, 0x78, 0x0c, 0xf8, 0x30, 0x00,
  0x00, 0xc6, 0xcc, 0x18, 0x30, 0x66, 0xc6, 0x00,
  0x38, 0x6c, 0x38, 0x76, 0xdc, 0xcc, 0x76, 0x00,
  0x60, 0x60, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x18, 0x30, 0x60, 0x60, 0x60, 0x30, 0x18, 0x00,
  0x60, 0x30, 0x18, 0x18, 0x18, 0x30, 0x60, 0x00,
  0x00, 0x66, 0x3c, 0xff, 0x3c, 0x66, 0x00, 0x00,
  0x00, 0x30, 0x30, 0xfc, 0x30, 0x30, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x60,
  0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00,
  0x06, 0x0c, 0x18, 0x30, 0x60, 0xc0, 0x80, 0x00,
  0x7c, 0xc6, 0xce, 0xde, 0xf6, 0xe6, 0x7c, 0x00,
  0x30, 0x70, 0x30, 0x30, 0x30, 0x30, 0xfc, 0x00,
  0x78, 0xcc, 0x0c, 0x38, 0x60, 0xcc, 0xfc, 0x00,
  0x78, 0xcc, 0x0c, 0x38, 0x0c, 0xcc, 0x78, 0x00,
  0x1c, 0x3c, 0x6c, 0xcc, 0xfe, 0x0c, 0x1e, 0x00,
  0xfc, 0xc0, 0xf8, 0x0c, 0x0c, 0xcc, 0x78, 0x00,
  0x38, 0x60, 0xc0, 0xf8, 0xcc, 0xcc, 0x78, 0x00,
  0xfc, 0xcc, 0x0c, 0x18, 0x30, 0x30, 0x30, 0x00,
  0x78, 0xcc, 0xcc, 0x78, 0xcc, 0xcc, 0x78, 0x00,
  0x78, 0xcc, 0xcc, 0x7c, 0x0c, 0x18, 0x70, 0x00,
  0x00, 0x30, 0x30, 0x00, 0x00, 0x30, 0x30, 0x00,
  0x00, 0x30, 0x30, 0x00, 0x00, 0x30, 0x30, 0x60,
  0x18, 0x30, 0x60, 0xc0, 0x60, 0x30, 0x18, 0x00,
  0x00, 0x00, 0xfc, 0x00, 0x00, 0xfc, 0x00, 0x00,
  0x60, 0x30, 0x18, 0x0c, 0x18, 0x30, 0x60, 0x00,
  0x78, 0xcc, 0x0c, 0x18, 0x30, 0x00, 0x30, 0x00,
  0x7c, 0xc6, 0xde, 0xde, 0xde, 0xc0, 0x78, 0x00,
  0x30, 0x78, 0xcc, 0xcc, 0xfc, 0xcc, 0xcc, 0x00,
  0xfc, 0x66, 0x66, 0x7c, 0x66, 0x66, 0xfc, 0x00,
  0x3c, 0x66, 0xc0, 0xc0, 0xc0, 0x66, 0x3c, 0x00,
  0xf8, 0x6c, 0x66, 0x66, 0x66, 0x6c, 0xf8, 0x00,
  0xfe, 0x62, 0x68, 0x78, 0x68, 0x62, 0xfe, 0x00,
  0xfe, 0x62, 0x68, 0x78, 0x68, 0x60, 0xf0, 0x00,
  0x3c, 0x66, 0xc0, 0xc0, 0xce, 0x66, 0x3e, 0x00,
  0xcc, 0xcc, 0xcc, 0xfc, 0xcc, 0xcc, 0xcc, 0x00,
  0x78, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00,
  0x1e, 0x0c, 0x0c, 0x0c, 0xcc, 0xcc, 0x78, 0x00,
  0xe6, 0x66, 0x6c, 0x78, 0x6c, 0x66, 0xe6, 0x00,
  0xf0, 0x60, 0x60, 0x60, 0x62, 0x66, 0xfe, 0x00,
  0xc6, 0xee, 0xfe, 0xfe, 0xd6, 0xc6, 0xc6, 0x00,
  0xc6, 0xe6, 0xf6, 0xde, 0xce, 0xc6, 0xc6, 0x00,
  0x38, 0x6c, 0xc6, 0xc6, 0xc6, 0x6c, 0x38, 0x00,
  0xfc, 0x66, 0x66, 0x7c, 0x60, 0x60, 0xf0, 0x00,
  0x78, 0xcc, 0xcc, 0xcc, 0xdc, 0x78, 0x1c, 0x00,
  0xfc, 0x66, 0x66, 0x7c, 0x6c, 0x66, 0xe6, 0x00,
  0x78, 0xcc, 0xe0, 0x70, 0x1c, 0xcc, 0x78, 0x00,
  0xfc, 0xb4, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00,
  0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xfc, 0x00,
  0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x00,
  0xc6, 0xc6, 0xc6, 0xd6, 0xfe, 0xee, 0xc6, 0x00,
  0xc6, 0xc6, 0x6c, 0x38, 0x38, 0x6c, 0xc6, 0x00,
  0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x30, 0x78, 0x00,
  0xfe, 0xc6, 0x8c, 0x18, 0x32, 0x66, 0xfe, 0x00,
  0x78, 0x60, 0x60, 0x60, 0x60, 0x60, 0x78, 0x00,
  0xc0, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x02, 0x00,
  0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0x78, 0x00,
  0x10, 0x38, 0x6c, 0xc6, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
  0x30, 0x30, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0x76, 0x00,
  0xe0, 0x60, 0x60, 0x7c, 0x66, 0x66, 0xdc, 0x00,
  0x00, 0x00, 0x78, 0xcc, 0xc0, 0xcc, 0x78, 0x00,
  0x1c, 0x0c, 0x0c, 0x7c, 0xcc, 0xcc, 0x76, 0x00,
  0x00, 0x00, 0x78, 0xcc, 0xfc, 0xc0, 0x78, 0x00,
  0x38, 0x6c, 0x60, 0xf0, 0x60, 0x60, 0xf0, 0x00,
  0x00, 0x00, 0x76, 0xcc, 0xcc, 0x7c, 0x0c, 0xf8,
  0xe0, 0x60, 0x6c, 0x76, 0x66, 0x66, 0xe6, 0x00,
  0x30, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00,
  0x0c, 0x00, 0x0c, 0x0c, 0x0c, 0xcc, 0xcc, 0x78,
  0xe0, 0x60, 0x66, 0x6c, 0x78, 0x6c, 0xe6, 0x00,
  0x70, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00,
  0x00, 0x00, 0xcc, 0xfe, 0xfe, 0xd6, 0xc6, 0x00,
  0x00, 0x00, 0xf8, 0xcc, 0xcc, 0xcc, 0xcc, 0x00,
  0x00, 0x00, 0x78, 0xcc, 0xcc, 0xcc, 0x78, 0x00,
  0x00, 0x00, 0xdc, 0x66, 0x66, 0x7c, 0x60, 0xf0,
  0x00, 0x00, 0x76, 0xcc, 0xcc, 0x7c, 0x0c, 0x1e,
  0x00, 0x00, 0xdc, 0x76, 0x66, 0x60, 0xf0, 0x00,
  0x00, 0x00, 0x7c, 0xc0, 0x78, 0x0c, 0xf8, 0x00,
  0x10, 0x30, 0x7c, 0x30, 0x30, 0x34, 0x18, 0x00,
  0x00, 0x00, 0xcc, 0xcc, 0xcc, 0xcc, 0x76, 0x00,
  0x00, 0x00, 0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x00,
  0x00, 0x00, 0xc6, 0xd6, 0xfe, 0xfe, 0x6c, 0x00,
  0x00, 0x00, 0xc6, 0x6c, 0x38, 0x6c, 0xc6, 0x00,
  0x00, 0x00, 0xcc, 0xcc, 0xcc, 0x7c, 0x0c, 0xf8,
  0x00, 0x00, 0xfc, 0x98, 0x30, 0x64, 0xfc, 0x00,
  0x1c, 0x30, 0x30, 0xe0, 0x30, 0x30, 0x1c, 0x00,
  0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00,
  0xe0, 0x30, 0x30, 0x1c, 0x30, 0x30, 0xe0, 0x00,
  0x76, 0xdc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x10, 0x38, 0x6c, 0xc6, 0xc6, 0xfe, 0x00,
};

#define IMAGE_OP_END			0x00

#define IMAGE_OP_SET_TEXT_POS		0x10

#define IMAGE_OP_PEN_COLOR_A		0x20
#define IMAGE_OP_PEN_COLOR_B		0x21
#define IMAGE_OP_PEN_COLOR_C		0x22
#define IMAGE_OP_PEN_COLOR_D		0x23
#define IMAGE_OP_PEN_COLOR_E		0x24
#define IMAGE_OP_PEN_COLOR_F		0x25
#define IMAGE_OP_PEN_COLOR_G		0x26
#define IMAGE_OP_PEN_COLOR_H		0x27

#define IMAGE_OP_DRAW_CHAR		0x30

#define IMAGE_OP_SHAPE_PIXEL		0x40
#define IMAGE_OP_SHAPE_BOX		0x41
#define IMAGE_OP_SHAPE_CIRCLE_TINY	0x42
#define IMAGE_OP_SHAPE_CIRCLE_SMALL	0x43
#define IMAGE_OP_SHAPE_CIRCLE_MED	0x44
#define IMAGE_OP_SHAPE_CIRCLE_LARGE	0x45
#define IMAGE_OP_SHAPE_A		0x46
#define IMAGE_OP_SHAPE_SPRAY		0x47

#define IMAGE_OP_EOF			0x55

#define IMAGE_OP_FILL_COLOR		0x60

#define IMAGE_OP_MOVE_TO		0x80
#define IMAGE_OP_MOVE_TO_FAR		0x81

#define IMAGE_OP_DRAW_BOX		0x90
#define IMAGE_OP_DRAW_BOX_FAR		0x91

#define IMAGE_OP_DRAW_LINE		0xa0
#define IMAGE_OP_DRAW_LINE_FAR		0xa1

#define IMAGE_OP_DRAW_SHAPE		0xc0
#define IMAGE_OP_DRAW_SHAPE_FAR		0xc1

#define IMAGE_OP_PAINT			0xe0
#define IMAGE_OP_PAINT_FAR		0xe1

static const int kGraphicsWidth	= 278;
static const int kGraphicsHeight = 200;

static const int penColors[] = {
	Renderer::kColorWhite,
	1,
	2,
	Renderer::kColorWhite,
	Renderer::kColorBlack,
	5,
	6,
	7
};

Renderer::Renderer(ImageManager *imageManager) : _imageManager(imageManager) {
	byte _palette[256 * 3] = {
		0xff, 0xff, 0xff, // 00
		0x00, 0x00, 0x00, // 01
		0x00, 0xff, 0x00, // 02
		0x00, 0xff, 0x00, // 03
		0x00, 0xff, 0x00, // 04
		0x00, 0xff, 0x00, // 05
		0x00, 0xff, 0x00, // 06
		0x00, 0xff, 0x00, // 07
		0x00, 0xff, 0x00, // 08
		0x00, 0xff, 0x00, // 09
		0x00, 0xff, 0x00, // 0a
		0x00, 0xff, 0x00, // 0b
		0x00, 0xff, 0x00, // 0c
		0x00, 0xff, 0x00, // 0d
		0x00, 0xff, 0x00, // 0e
		0x00, 0xff, 0x00, // 0f

		0x00, 0xff, 0x00, // 10
		0x00, 0xff, 0x00, // 11
		0x00, 0xff, 0x00, // 12
		0x00, 0xff, 0x00, // 13
		0x00, 0xff, 0x00, // 14
		0x00, 0xff, 0x00, // 15
		0x00, 0xff, 0x00, // 16
		0x00, 0xff, 0x00, // 17
		0x00, 0xff, 0x00, // 18
		0x00, 0xff, 0x00, // 19
		0x00, 0xff, 0x00, // 1a
		0x00, 0xff, 0x00, // 1b
		0x00, 0xff, 0x00, // 1c
		0x00, 0xff, 0x00, // 1d
		0x00, 0xff, 0x00, // 1e
		0x00, 0xff, 0x00, // 1f

		0x00, 0xff, 0x00, // 20
		0x00, 0xff, 0x00, // 21
		0x00, 0xff, 0x00, // 22
		0x00, 0xff, 0x00, // 23
		0x00, 0xff, 0x00, // 24
		0x00, 0xff, 0x00, // 25
		0x00, 0xff, 0x00, // 26
		0x00, 0xff, 0x00, // 27
		0x00, 0xff, 0x00, // 28
		0x00, 0xff, 0x00, // 29
		0x00, 0xff, 0x00, // 2a
		0x00, 0xff, 0x00, // 2b
		0x00, 0xff, 0x00, // 2c
		0x00, 0xff, 0x00, // 2d
		0x00, 0xff, 0x00, // 2e
		0x00, 0xff, 0x00, // 2f

		0x00, 0xff, 0x00, // 30
		0x00, 0xff, 0x00, // 31
		0x00, 0xff, 0x00, // 32
		0x00, 0xff, 0x00, // 33
		0x00, 0xff, 0x00, // 34
		0x00, 0xff, 0x00, // 35
		0x00, 0xff, 0x00, // 36
		0x00, 0xff, 0x00, // 37
		0x00, 0xff, 0x00, // 38
		0x00, 0xff, 0x00, // 39
		0x00, 0xff, 0x00, // 3a
		0x00, 0xff, 0x00, // 3b
		0x00, 0xff, 0x00, // 3c
		0x00, 0xff, 0x00, // 3d
		0x00, 0xff, 0x00, // 3e
		0x00, 0xff, 0x00, // 3f

		0x00, 0xff, 0x00, // 40
		0x00, 0xff, 0x00, // 41
		0x00, 0xff, 0x00, // 42
		0x00, 0xff, 0x00, // 43
		0x00, 0xff, 0x00, // 44
		0x00, 0xff, 0x00, // 45
		0x00, 0xff, 0x00, // 46
		0x00, 0xff, 0x00, // 47
		0x00, 0xff, 0x00, // 48
		0x00, 0xff, 0x00, // 49
		0x00, 0xff, 0x00, // 4a
		0x00, 0xff, 0x00, // 4b
		0x00, 0xff, 0x00, // 4c
		0x00, 0xff, 0x00, // 4d
		0x00, 0xff, 0x00, // 4e
		0x00, 0xff, 0x00, // 4f

		0x00, 0x00, 0x00, // 50 (black)
		0x00, 0xff, 0x00, // 51
		0x00, 0xff, 0x00, // 52
		0x00, 0xff, 0x00, // 53
		0x00, 0xff, 0x00, // 54
		0x00, 0xff, 0x00, // 55
		0x00, 0xff, 0x00, // 56
		0x00, 0xff, 0x00, // 57
		0x00, 0xff, 0x00, // 58
		0x00, 0xff, 0x00, // 59
		0x00, 0xff, 0x00, // 5a
		0x00, 0xff, 0x00, // 5b
		0x00, 0xff, 0x00, // 5c
		0x00, 0xff, 0x00, // 5d
		0x00, 0xff, 0x00, // 5e
		0x00, 0xff, 0x00, // 5f

		0x00, 0xff, 0x00, // 60
		0x00, 0xff, 0x00, // 61
		0x00, 0xff, 0x00, // 62
		0x00, 0xff, 0x00, // 63
		0x00, 0xff, 0x00, // 64
		0x00, 0xff, 0x00, // 65
		0x00, 0xff, 0x00, // 66
		0x00, 0xff, 0x00, // 67
		0x00, 0xff, 0x00, // 68
		0x00, 0xff, 0x00, // 69
		0x00, 0xff, 0x00, // 6a
		0x00, 0xff, 0x00, // 6b
		0x00, 0xff, 0x00, // 6c
		0x00, 0xff, 0x00, // 6d
		0x00, 0xff, 0x00, // 6e
		0x00, 0xff, 0x00, // 6f

		0x00, 0xff, 0x00, // 70
		0x00, 0xff, 0x00, // 71
		0x00, 0xff, 0x00, // 72
		0x00, 0xff, 0x00, // 73
		0x00, 0xff, 0x00, // 74
		0x00, 0xff, 0x00, // 75
		0x00, 0xff, 0x00, // 76
		0x00, 0xff, 0x00, // 77
		0x00, 0xff, 0x00, // 78
		0x00, 0xff, 0x00, // 79
		0x00, 0xff, 0x00, // 7a
		0x00, 0xff, 0x00, // 7b
		0x00, 0xff, 0x00, // 7c
		0x00, 0xff, 0x00, // 7d
		0x00, 0xff, 0x00, // 7e
		0x00, 0xff, 0x00, // 7f

		0x00, 0x00, 0x00, // 80
	};
	
	g_system->getPaletteManager()->setPalette(_palette, 0, 0x80);

	_surf.create(kGraphicsWidth, kGraphicsHeight, Graphics::PixelFormat::createFormatCLUT8());
}

Renderer::~Renderer() {
	_surf.free();
}

int Renderer::getPixel(int x, int y) {
	byte *pixelData;

	pixelData = (byte *)_surf.getPixels();
	return pixelData[(kGraphicsWidth * y) + x];
}

void Renderer::floodFill(int x, int y, int oldColor) {
	int x1, x2, i;

	if (getPixel(x, y) != oldColor || _fillColor == oldColor)
		return;

	// Find the left and right ends of the current scanline
	for (x1 = x; x1 > 0; x1--)
		if (getPixel(x1 - 1, y) != oldColor)
			break;
	for (x2 = x; x2 < kGraphicsWidth - 1; x2++)
		if (getPixel(x2 + 1, y) != oldColor)
			break;

	// Draw the current scanline
	_surf.drawLine(x1, y, x2, y, _fillColor);

	// Recursively draw the above scanlines
	for (i = x1; i < x2; i++)
		if (y > 0 && getPixel(i, y - 1) == oldColor)
			floodFill(i, y - 1, oldColor);

	// Recursively draw the below scanlines
	for (i = x1; i < x2; i++)
		if (y < kGraphicsHeight - 1 && getPixel(i, y + 1) == oldColor)
			floodFill(i, y + 1, oldColor);
}

void Renderer::doImageOpcode(Common::File *file, uint8 opcode) {
	unsigned int a, b;

	switch (opcode) {
	case IMAGE_OP_MOVE_TO:
	case IMAGE_OP_MOVE_TO_FAR:
		a = file->readByte();
		b = file->readByte();

		if (opcode & 0x1)
			a += 0xff;

		debugC(1, Comprehend::kDebugGraphics, "move_to(%d, %d)", a, b);
		_penX = a;
		_penY = b;
		break;

	case IMAGE_OP_DRAW_LINE:
	case IMAGE_OP_DRAW_LINE_FAR:
		a = file->readByte();
		b = file->readByte();

		if (opcode & 1)
			a += 0xff;
		
		debugC(1, Comprehend::kDebugGraphics, "line(%d, %d)-(%d, %d), color=%.2x", _penX, _penY, a, b, _penColor);
		_surf.drawLine(_penX, _penY, a, b, _penColor);
		_penX = a;
		_penY = b;
		break;

	case IMAGE_OP_DRAW_BOX:
	case IMAGE_OP_DRAW_BOX_FAR:
		// FIXME
		a = file->readByte();
		b = file->readByte();
		break;

	case IMAGE_OP_SHAPE_PIXEL:
	case IMAGE_OP_SHAPE_BOX:
	case IMAGE_OP_SHAPE_CIRCLE_TINY:
	case IMAGE_OP_SHAPE_CIRCLE_SMALL:
	case IMAGE_OP_SHAPE_CIRCLE_MED:
	case IMAGE_OP_SHAPE_CIRCLE_LARGE:
	case IMAGE_OP_SHAPE_A:
	case IMAGE_OP_SHAPE_SPRAY:
		// FIXME
		break;

	case IMAGE_OP_DRAW_SHAPE:
	case IMAGE_OP_DRAW_SHAPE_FAR:
		// FIXME
		a = file->readByte();
		b = file->readByte();
		break;

	case IMAGE_OP_SET_TEXT_POS:
		// FIXME
		a = file->readByte();
		b = file->readByte();
		break;

	case IMAGE_OP_DRAW_CHAR:
		// FIXME
		a = file->readByte();
		break;

	case IMAGE_OP_PAINT:
	case IMAGE_OP_PAINT_FAR:
		a = file->readByte();
		b = file->readByte();

		if (opcode & 0x1)
			a += 0xff;

		debugC(1, Comprehend::kDebugGraphics, "paint(%d, %d) color=%.2x", a, b, _fillColor);
		floodFill(a, b, getPixel(a, b));
		break;

	case IMAGE_OP_PEN_COLOR_A:
	case IMAGE_OP_PEN_COLOR_B:
	case IMAGE_OP_PEN_COLOR_C:
	case IMAGE_OP_PEN_COLOR_D:
	case IMAGE_OP_PEN_COLOR_E:
	case IMAGE_OP_PEN_COLOR_F:
	case IMAGE_OP_PEN_COLOR_G:
	case IMAGE_OP_PEN_COLOR_H:
		// FIXME
		break;

	case IMAGE_OP_FILL_COLOR:
		_fillColor = file->readByte();
		debugC(1, Comprehend::kDebugGraphics, "set_fill_color(%.2x)", _fillColor);  
		break;

	default:
		debugC(1, Comprehend::kDebugGraphics, "  unknown opcode %.2x", opcode);
		break;
	}
}

void Renderer::updateScreen() {
	int xPad;

	debug("Renderer::updateScreen");

	xPad = (g_system->getWidth() - kGraphicsWidth) / 2;

	g_system->copyRectToScreen(_surf.getPixels(), kGraphicsWidth, xPad, 0, g_system->getWidth() - xPad, kGraphicsHeight);
	g_system->updateScreen();
}

void Renderer::drawImage(Common::File *file, off_t offset) {
	uint8 opcode;

	_penX = 0;
	_penY = 0;
	_penColor = kColorBlack;
	_fillColor = kColorWhite;

	file->seek(offset, SEEK_SET);
	while (1) {		
		opcode = file->readByte();
		if (opcode == IMAGE_OP_END)
			break;

		doImageOpcode(file, opcode);

		updateScreen();
		//g_system->delayMillis(10);
	}
}

void Renderer::drawRoomImage(uint16 index) {
	unsigned int fileIndex, imageIndex;
	ImageFile *imageFile;

	fileIndex  = index / ImageFile::kImagesPerFile;
	imageIndex = index % ImageFile::kImagesPerFile;

	if (fileIndex >= _imageManager->_roomImageFiles.size())
		error("Invalid room image index %d\n", index);

	imageFile = _imageManager->_roomImageFiles[fileIndex];

	// Clear to white
	_surf.fillRect(Common::Rect(0, 0, kGraphicsWidth, kGraphicsHeight), kColorWhite);
	updateScreen();
	
	drawImage(&imageFile->_file, imageFile->_imageOffsets[imageIndex]);

	// Blank the area for the text parser
	_surf.fillRect(Common::Rect(0, 160, kGraphicsWidth, kGraphicsHeight), kColorBlack);
	updateScreen();
}

void Renderer::drawChar(uint8 c, int x, int y, int color) {
	const uint8 *charData;
	int i, j;

	if (c >= 128)
		return;
	
	charData = &dosFont[c * 8];
	for (i = 0; i < 8; i++) {
		for (j = 7; j >= 0; j--) {
			if (*charData & (1 << j))
				_surf.fillRect(Common::Rect(x, y, x + 1, y + 1), color);
			x++;
		}
		
		charData++;
		y++;
		x -= 8;
	}
	
	//updateScreen();
}

void Renderer::drawString(const char *string, int x, int y, int color) {
	unsigned int i;

	for (i = 0; i < strlen(string); i++)
		drawChar(string[i], x + (i * 8), y, color);

	//updateScreen();
}

void Renderer::copyRect(const void *pixels, int pitch, Common::Rect rect) {
//void Renderer::copyRect(Graphics::Surface &srcSurf, Common::Rect srcRect, int x, int y) {	
	debug("Copy rect to screen: x=%d, y=%d, w=%d, h=%d",
	      rect.left, rect.top, rect.width(), rect.height());
	g_system->copyRectToScreen(pixels, pitch, rect.left, rect.top, rect.width(), rect.height());
	g_system->updateScreen();
}

} // End of namespace Comprehend
