#include "common/rect.h"
#include "common/debug.h"
#include "common/system.h"
#include "common/events.h"
#include "common/keyboard.h"

#include "comprehend/comprehend.h"
#include "comprehend/renderer.h"
#include "comprehend/console.h"

namespace Comprehend {

static const int kMaxCharsPerLine        =  40;
static const int kCharSize               =   8;
static const int kBottomLine             = 200 - kCharSize;
static const int kGraphicsModeNumLines   = 5;

static const int kTextModeTop            = 0;
static const int kGraphicsModeTop        = 200 - (kGraphicsModeNumLines * kCharSize);

static const char kPromptChar            = '>';
static const char kReplaceChar           = '@';
static const uint32 kPromptUpdateTimeout = 250;

static const uint8 dosFont[128 * 8] = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x7e, 0x81, 0xa5, 0x81, 0xbd, 0x99, 0x81, 0x7e,
	0x7e, 0xff, 0xdb, 0xff, 0xc3, 0xe7, 0xff, 0x7e,
	0x6c, 0xfe, 0xfe, 0xfe, 0x7c, 0x38, 0x10, 0x00,
	0x10, 0x38, 0x7c, 0xfe, 0x7c, 0x38, 0x10, 0x00,
	0x38, 0x7c, 0x38, 0xfe, 0xfe, 0x7c, 0x38, 0x7c,
	0x10, 0x10, 0x38, 0x7c, 0xfe, 0x7c, 0x38, 0x7c,
	0x00, 0x00, 0x18, 0x3c, 0x3c, 0x18, 0x00, 0x00,
	0xff, 0xff, 0xe7, 0xc3, 0xc3, 0xe7, 0xff, 0xff,
	0x00, 0x3c, 0x66, 0x42, 0x42, 0x66, 0x3c, 0x00,
	0xff, 0xc3, 0x99, 0xbd, 0xbd, 0x99, 0xc3, 0xff,
	0x0f, 0x07, 0x0f, 0x7d, 0xcc, 0xcc, 0xcc, 0x78,
	0x3c, 0x66, 0x66, 0x66, 0x3c, 0x18, 0x7e, 0x18,
	0x3f, 0x33, 0x3f, 0x30, 0x30, 0x70, 0xf0, 0xe0,
	0x7f, 0x63, 0x7f, 0x63, 0x63, 0x67, 0xe6, 0xc0,
	0x99, 0x5a, 0x3c, 0xe7, 0xe7, 0x3c, 0x5a, 0x99,
	0x80, 0xe0, 0xf8, 0xfe, 0xf8, 0xe0, 0x80, 0x00,
	0x02, 0x0e, 0x3e, 0xfe, 0x3e, 0x0e, 0x02, 0x00,
	0x18, 0x3c, 0x7e, 0x18, 0x18, 0x7e, 0x3c, 0x18,
	0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x66, 0x00,
	0x7f, 0xdb, 0xdb, 0x7b, 0x1b, 0x1b, 0x1b, 0x00,
	0x3e, 0x63, 0x38, 0x6c, 0x6c, 0x38, 0xcc, 0x78,
	0x00, 0x00, 0x00, 0x00, 0x7e, 0x7e, 0x7e, 0x00,
	0x18, 0x3c, 0x7e, 0x18, 0x7e, 0x3c, 0x18, 0xff,
	0x18, 0x3c, 0x7e, 0x18, 0x18, 0x18, 0x18, 0x00,
	0x18, 0x18, 0x18, 0x18, 0x7e, 0x3c, 0x18, 0x00,
	0x00, 0x18, 0x0c, 0xfe, 0x0c, 0x18, 0x00, 0x00,
	0x00, 0x30, 0x60, 0xfe, 0x60, 0x30, 0x00, 0x00,
	0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xfe, 0x00, 0x00,
	0x00, 0x24, 0x66, 0xff, 0x66, 0x24, 0x00, 0x00,
	0x00, 0x18, 0x3c, 0x7e, 0xff, 0xff, 0x00, 0x00,
	0x00, 0xff, 0xff, 0x7e, 0x3c, 0x18, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x30, 0x78, 0x78, 0x30, 0x30, 0x00, 0x30, 0x00,
	0x6c, 0x6c, 0x6c, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x6c, 0x6c, 0xfe, 0x6c, 0xfe, 0x6c, 0x6c, 0x00,
	0x30, 0x7c, 0xc0, 0x78, 0x0c, 0xf8, 0x30, 0x00,
	0x00, 0xc6, 0xcc, 0x18, 0x30, 0x66, 0xc6, 0x00,
	0x38, 0x6c, 0x38, 0x76, 0xdc, 0xcc, 0x76, 0x00,
	0x60, 0x60, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x18, 0x30, 0x60, 0x60, 0x60, 0x30, 0x18, 0x00,
	0x60, 0x30, 0x18, 0x18, 0x18, 0x30, 0x60, 0x00,
	0x00, 0x66, 0x3c, 0xff, 0x3c, 0x66, 0x00, 0x00,
	0x00, 0x30, 0x30, 0xfc, 0x30, 0x30, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x60,
	0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00,
	0x06, 0x0c, 0x18, 0x30, 0x60, 0xc0, 0x80, 0x00,
	0x7c, 0xc6, 0xce, 0xde, 0xf6, 0xe6, 0x7c, 0x00,
	0x30, 0x70, 0x30, 0x30, 0x30, 0x30, 0xfc, 0x00,
	0x78, 0xcc, 0x0c, 0x38, 0x60, 0xcc, 0xfc, 0x00,
	0x78, 0xcc, 0x0c, 0x38, 0x0c, 0xcc, 0x78, 0x00,
	0x1c, 0x3c, 0x6c, 0xcc, 0xfe, 0x0c, 0x1e, 0x00,
	0xfc, 0xc0, 0xf8, 0x0c, 0x0c, 0xcc, 0x78, 0x00,
	0x38, 0x60, 0xc0, 0xf8, 0xcc, 0xcc, 0x78, 0x00,
	0xfc, 0xcc, 0x0c, 0x18, 0x30, 0x30, 0x30, 0x00,
	0x78, 0xcc, 0xcc, 0x78, 0xcc, 0xcc, 0x78, 0x00,
	0x78, 0xcc, 0xcc, 0x7c, 0x0c, 0x18, 0x70, 0x00,
	0x00, 0x30, 0x30, 0x00, 0x00, 0x30, 0x30, 0x00,
	0x00, 0x30, 0x30, 0x00, 0x00, 0x30, 0x30, 0x60,
	0x18, 0x30, 0x60, 0xc0, 0x60, 0x30, 0x18, 0x00,
	0x00, 0x00, 0xfc, 0x00, 0x00, 0xfc, 0x00, 0x00,
	0x60, 0x30, 0x18, 0x0c, 0x18, 0x30, 0x60, 0x00,
	0x78, 0xcc, 0x0c, 0x18, 0x30, 0x00, 0x30, 0x00,
	0x7c, 0xc6, 0xde, 0xde, 0xde, 0xc0, 0x78, 0x00,
	0x30, 0x78, 0xcc, 0xcc, 0xfc, 0xcc, 0xcc, 0x00,
	0xfc, 0x66, 0x66, 0x7c, 0x66, 0x66, 0xfc, 0x00,
	0x3c, 0x66, 0xc0, 0xc0, 0xc0, 0x66, 0x3c, 0x00,
	0xf8, 0x6c, 0x66, 0x66, 0x66, 0x6c, 0xf8, 0x00,
	0xfe, 0x62, 0x68, 0x78, 0x68, 0x62, 0xfe, 0x00,
	0xfe, 0x62, 0x68, 0x78, 0x68, 0x60, 0xf0, 0x00,
	0x3c, 0x66, 0xc0, 0xc0, 0xce, 0x66, 0x3e, 0x00,
	0xcc, 0xcc, 0xcc, 0xfc, 0xcc, 0xcc, 0xcc, 0x00,
	0x78, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00,
	0x1e, 0x0c, 0x0c, 0x0c, 0xcc, 0xcc, 0x78, 0x00,
	0xe6, 0x66, 0x6c, 0x78, 0x6c, 0x66, 0xe6, 0x00,
	0xf0, 0x60, 0x60, 0x60, 0x62, 0x66, 0xfe, 0x00,
	0xc6, 0xee, 0xfe, 0xfe, 0xd6, 0xc6, 0xc6, 0x00,
	0xc6, 0xe6, 0xf6, 0xde, 0xce, 0xc6, 0xc6, 0x00,
	0x38, 0x6c, 0xc6, 0xc6, 0xc6, 0x6c, 0x38, 0x00,
	0xfc, 0x66, 0x66, 0x7c, 0x60, 0x60, 0xf0, 0x00,
	0x78, 0xcc, 0xcc, 0xcc, 0xdc, 0x78, 0x1c, 0x00,
	0xfc, 0x66, 0x66, 0x7c, 0x6c, 0x66, 0xe6, 0x00,
	0x78, 0xcc, 0xe0, 0x70, 0x1c, 0xcc, 0x78, 0x00,
	0xfc, 0xb4, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00,
	0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xfc, 0x00,
	0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x00,
	0xc6, 0xc6, 0xc6, 0xd6, 0xfe, 0xee, 0xc6, 0x00,
	0xc6, 0xc6, 0x6c, 0x38, 0x38, 0x6c, 0xc6, 0x00,
	0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x30, 0x78, 0x00,
	0xfe, 0xc6, 0x8c, 0x18, 0x32, 0x66, 0xfe, 0x00,
	0x78, 0x60, 0x60, 0x60, 0x60, 0x60, 0x78, 0x00,
	0xc0, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x02, 0x00,
	0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0x78, 0x00,
	0x10, 0x38, 0x6c, 0xc6, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
	0x30, 0x30, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0x76, 0x00,
	0xe0, 0x60, 0x60, 0x7c, 0x66, 0x66, 0xdc, 0x00,
	0x00, 0x00, 0x78, 0xcc, 0xc0, 0xcc, 0x78, 0x00,
	0x1c, 0x0c, 0x0c, 0x7c, 0xcc, 0xcc, 0x76, 0x00,
	0x00, 0x00, 0x78, 0xcc, 0xfc, 0xc0, 0x78, 0x00,
	0x38, 0x6c, 0x60, 0xf0, 0x60, 0x60, 0xf0, 0x00,
	0x00, 0x00, 0x76, 0xcc, 0xcc, 0x7c, 0x0c, 0xf8,
	0xe0, 0x60, 0x6c, 0x76, 0x66, 0x66, 0xe6, 0x00,
	0x30, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00,
	0x0c, 0x00, 0x0c, 0x0c, 0x0c, 0xcc, 0xcc, 0x78,
	0xe0, 0x60, 0x66, 0x6c, 0x78, 0x6c, 0xe6, 0x00,
	0x70, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00,
	0x00, 0x00, 0xcc, 0xfe, 0xfe, 0xd6, 0xc6, 0x00,
	0x00, 0x00, 0xf8, 0xcc, 0xcc, 0xcc, 0xcc, 0x00,
	0x00, 0x00, 0x78, 0xcc, 0xcc, 0xcc, 0x78, 0x00,
	0x00, 0x00, 0xdc, 0x66, 0x66, 0x7c, 0x60, 0xf0,
	0x00, 0x00, 0x76, 0xcc, 0xcc, 0x7c, 0x0c, 0x1e,
	0x00, 0x00, 0xdc, 0x76, 0x66, 0x60, 0xf0, 0x00,
	0x00, 0x00, 0x7c, 0xc0, 0x78, 0x0c, 0xf8, 0x00,
	0x10, 0x30, 0x7c, 0x30, 0x30, 0x34, 0x18, 0x00,
	0x00, 0x00, 0xcc, 0xcc, 0xcc, 0xcc, 0x76, 0x00,
	0x00, 0x00, 0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x00,
	0x00, 0x00, 0xc6, 0xd6, 0xfe, 0xfe, 0x6c, 0x00,
	0x00, 0x00, 0xc6, 0x6c, 0x38, 0x6c, 0xc6, 0x00,
	0x00, 0x00, 0xcc, 0xcc, 0xcc, 0x7c, 0x0c, 0xf8,
	0x00, 0x00, 0xfc, 0x98, 0x30, 0x64, 0xfc, 0x00,
	0x1c, 0x30, 0x30, 0xe0, 0x30, 0x30, 0x1c, 0x00,
	0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00,
	0xe0, 0x30, 0x30, 0x1c, 0x30, 0x30, 0xe0, 0x00,
	0x76, 0xdc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x10, 0x38, 0x6c, 0xc6, 0xc6, 0xfe, 0x00,
};

Console::Console(Renderer *renderer) : _renderer(renderer) {
	int i;

	_promptBlinkState = 0;
	_promptUpdateTime = 0;

	_xOffset = 0;
	_scrollCount = 0;
	_inputCount = 0;

	// Flip between two surfaces for scrolling
	for (i = 0; i < 2; i++) {
		_surfs[i].create(g_system->getWidth(), g_system->getHeight(), Graphics::PixelFormat::createFormatCLUT8());
		_surfs[i].fillRect(Common::Rect(0, 0, g_system->getWidth(), g_system->getHeight()), Renderer::kColorBlack);
	}
	_currentSurf = 0;
}

Console::~Console() {
}

void Console::updateRect(Common::Rect rect) {
	_renderer->copyRect(_surfs[_currentSurf].getBasePtr(rect.left, rect.top), _surfs[_currentSurf].w, rect);
}

void Console::updateScreen() {
	byte *pixels;

	pixels  = (byte *)_surfs[_currentSurf].getPixels();
	pixels += _surfs[_currentSurf].w * kGraphicsModeTop;

	_renderer->copyRect(pixels, _surfs[_currentSurf].w, Common::Rect(0, kGraphicsModeTop, _surfs[_currentSurf].w, _surfs[_currentSurf].h));
}

void Console::scrollUp(bool pause) {
	uint16 width, height;

	_scrollCount++;
	if (_scrollCount == kGraphicsModeNumLines) {
		if (pause)
			waitKey();
		_scrollCount = 0;
	}

	width  = _surfs[_currentSurf].w;
	height = _surfs[_currentSurf].h;

	// Copy all but the top line to the other surf
	_surfs[_currentSurf ^ 1].copyRectToSurface(_surfs[_currentSurf], 0, 0, Common::Rect(0, kCharSize, width, height));

	// Blank the bottom line of the other surf
	_surfs[_currentSurf ^ 1].fillRect(Common::Rect(0, height - kCharSize, width, height), Renderer::kColorBlack);

	// Flip surfaces and reset offset
	_currentSurf ^= 1;
	_xOffset = 0;

	// FIXME - lazy
	updateScreen();
}

void Console::clearChar(void) {
	Common::Rect rect(_xOffset, kBottomLine, _xOffset + kCharSize, kBottomLine + kCharSize);

	_surfs[_currentSurf].fillRect(rect, Renderer::kColorBlack);
	updateRect(rect);
}

void Console::drawChar(uint8 c) {
	const uint8 *charData;
	int i, j, x, y;

	if (c >= 128)
		return;

	if (_xOffset >= kCharSize * kMaxCharsPerLine) {
		debug("Attempting to render char '%c' (%02x) at illegal offset %d", c, c, _xOffset);
		return;
	}

	charData = &dosFont[c * 8];
	for (i = 0; i < kCharSize; i++) {
		for (j = 0; j < kCharSize; j++) {
			if (*charData & (1 << (kCharSize - 1 - j))) {
				x = _xOffset + j;
				y = kBottomLine + i;

				_surfs[_currentSurf].fillRect(Common::Rect(x, y, x + 1, y + 1), Renderer::kColorWhite);
			}
		}

		charData++;
	}

	// Copy it to the screen
	updateRect(Common::Rect(_xOffset, kBottomLine, _xOffset + kCharSize, kBottomLine + kCharSize));
}

void Console::nextChar(void) {
	_xOffset += kCharSize;
}

void Console::drawString(const char *str, size_t len) {
	size_t i;

	for (i = 0; i < len; i++) {
		drawChar(str[i]);
		nextChar();
	}
}

void Console::drawPrompt(void) {
	drawChar('>');
	nextChar();
}

void Console::writeWrappedText(const char *text) {
	const char *p, *replace, *word;
	size_t wordLen, lineLength;

	word = NULL;
	lineLength = 0;
	p = text;

	while (p && *p) {
		switch (*p) {
		case '\n':
			word = NULL;
			wordLen = 0;
			lineLength = 0;
			scrollUp(true);
			p++;
			break;

		case kReplaceChar:
			// FIXME
			word = "[FIXME]";
			wordLen = strlen(word);
			p++;
			break;

		default:
			// Find next space or newline
			wordLen = strcspn(p, " \n");
			if (wordLen == 0)
				break;

			 // If this word contains a replacement symbol, then
			 // print everything before the symbol.
			replace = (const char *)memchr(p, kReplaceChar, wordLen);
			if (replace)
				wordLen = replace - p;

			word = p;
			p += wordLen;
			break;
		}

		if (!word || !wordLen)
			continue;

		if (lineLength + wordLen > kMaxCharsPerLine) {
			// Too long - scroll up
			lineLength = 0;
			scrollUp(true);
		}

		drawString(word, wordLen);
		lineLength += wordLen;
		wordLen = 0;

		if (*p == ' ') {
			if (lineLength >= kMaxCharsPerLine) {
				// Need to scroll, so don't print the newline
				lineLength = 0;
				scrollUp(true);
			} else {
				nextChar();
				lineLength++;
			}
			p++;

			// Skip any double spaces
			while (*p == ' ')
				p++;
		}
	}

	scrollUp(true);
}

bool Console::handleKey(int key) {
	char c;

	if ((key >= Common::KEYCODE_a && key <= Common::KEYCODE_z) || key == Common::KEYCODE_SPACE) {

		// Make sure there is space in the input buffer
		if (_inputCount >= sizeof(_inputBuffer))
			return false;

		// Always print uppercase letters
		if (key >= Common::KEYCODE_a && key <= Common::KEYCODE_z)
			c = 'A' + (key - Common::KEYCODE_a);
		else
			c = key;

		_inputBuffer[_inputCount++] = c;
		drawChar(c);
		nextChar();

	} else if (key == Common::KEYCODE_RETURN) {
		// FIXME - RETURN with no input switch graphics/text mode
		_inputBuffer[_inputCount] = '\0';
		_inputCount = 0;
		return true;

	} else if (key == Common::KEYCODE_BACKSPACE) {
		if (_xOffset != 0 && _inputCount != 0) {
			_inputCount--;
			_xOffset -= kCharSize;
			clearChar();
		}
	}

	return false;
}

char *Console::getLine(void) {
	Common::Event event;
	bool done = false;

	drawPrompt();
	while (!done) {
		// Blinking cursor
		if (g_system->getMillis() > _promptUpdateTime + kPromptUpdateTimeout) {
			if (_promptBlinkState)
				clearChar();
			else
				drawChar('.');

			_promptBlinkState ^= 1;
			_promptUpdateTime = g_system->getMillis();
			//updateScreen();
		}

		while (!done && g_system->getEventManager()->pollEvent(event)) {
			switch (event.type) {
			case Common::EVENT_KEYDOWN:
				// Ensure blinking prompt is not visible
				clearChar();
				done = handleKey(event.kbd.keycode);
				break;

			default:
				break;
			}

			g_system->delayMillis(1);
		}
		g_system->delayMillis(1);
	}

	scrollUp(false);
	_scrollCount = 0;
	return _inputBuffer;
}

void Console::waitKey() {
	Common::Event event;

	while (1) {
		while (g_system->getEventManager()->pollEvent(event))
			if (event.type == Common::EVENT_KEYDOWN)
				return;
	}
}

} // End of namespace Comprehend
